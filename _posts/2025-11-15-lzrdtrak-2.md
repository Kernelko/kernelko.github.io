---
layout: default
title: Lzrdtrak.exe:  First Steps
---

# Background

See the previous post on the actual background of this project. 

Currently we are just trying to build an interface. 

Why start with this? The idea is that I will

1) Build a database with dummy data that will pretend to be actual gecko data
2) Build an interface to display this dummy data and do whathever we need it to do
3) Connect the two together
4) Deploy the interface to raspberry pi for now, run it and expose on LAN, make sure it reruns on restart of the machine
5) Use Cloudfront (probably) to expose it to the internet so that it's accessible from the outside

And after that, the phase 2 would be actually connecting the sensors and stuff

# Building a database with dummy data

I wanted to be cool and use kdb+ which is some sort of superfast db that is being used by all the major banks. 

Unfortunately, they stopped having a free license and now to get a license you need to give them your personal data and it's free only for a year. So I decided that since there is a very high chance of me abandoning this project at any point and coming back to it months later, I will set it up with the next best thing (SQLite) and if this will actually be running, I'll get kgb+ later. Talk about mature decisions.

ok so lets start with

## Installing and creating a DB

> pacman -S sqlite3 libsqlite3-dev

> sqlite3 --version

> sqlite3 gecko.db

## Creating tables and such

Of course the simplest way would be to use  Python but who likes Python? I really want to stop being Python person. 

Let's try C.

```
#include <stdio.h>
#include <stdlib.h>
#include <sqlite3.h>
#include <time.h>

int main() {
	
	sqlite3 *db;
	char *err_msg = 0;
	int rc;
	
	// Open database
	
	rc = sqlite3_open("gecko.db", &db);
	if (rc != SQLITE_OK) {
		fprintf(stderr, "Cannot open database : %s\n", sqlite3_errmsg(db));
		sqlite3_close(db);
		return 1;
	}
	
	
	// create table
	
	char *sql = "CREATE TABLE IF NOT EXISTS readings ("
				"timestamp INTEGER PRIMARY KEY, "
				"temperature REAL,"
				"humidity REAL);";
	rc = sqlite3_exec(db, sql, 0,0, &err_msg);
	if (rc != SQLITE_OK) {
		fprintf(stderr, "SQL error: %s\n", err_msg);
		sqlite3_free(err_msg);
		sqlite_close(db);
		return 1;
	}
	
	// Generate 24 hours of data 1440 readings, 1 per minute)
	time_t now = time(NULL);
	time_t start_time = now - (24*60*60); // 24 hours ago
	
	printf("Generating 1440 readings...\n");
	
	// Begin transation for speed
	
	sqlite3_exec(db, "BEGIN TRANSACTION;", 0,0,0);
	
	for (int i = 0; i<1440; i++){
		
		time_t timestamp = start_time +  (i * 60)
		float temp = 22.0 + ((float)rand()/RAND_MAX)*6.0;
		flot  humidity = 30.0 + ((float)rand()/RAND_MAX)*20.0;
		
		char insert_sql[256];
		snprintf(insert_sql, sizeof(insertsql), 
				"INSERT INTO readings VALUES (%ld, %.1f, %.1f);", timestamp, temp, humidity);
		
		rc = sqlite3_exec(db, insert_sql, 0,0, &err_msg);
		if (rc != SQLITE_OK) {
			fprintf(stderr, "Insert error: %s\n", err_msg);
			sqlite3_free(err_msg);
		}
		if (i % 100 == 0){
			printf(".");
			fflush(stdout);
		}
	}
	
	sqlite3_exec(db, "COMMIT;", 0,0,0);
	
	printf("\nDONE! Generated 24 hours of dummy data. \n");
	sqlite3_close(db);
	return 0;
}

```

Now to compile this and run

> gcc -o generate_dummy_data generate_dummy_data.c -lsqlite3 ./generate_dummy_data

Verify if it worked

> sqlite3 gecko.db "SELECT COUNT(*) FROM readings;"
> sqlite3 gecko.db "SELECT datetime(timestamp, 'unixepoch'), temperature, humidity FROM readings LIMIT 5;"


[back](./)
